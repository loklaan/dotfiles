#!/usr/bin/env bash
set -euo pipefail

IFS=$'\n\t'

# Normalize TMPDIR
TMPDIR="${TMPDIR:-/tmp}"
TMPDIR="${TMPDIR%/}"

# Source shared logging library and setup session logging
source "${HOME}/.local/lib/bash-logging.sh"
setup_session_logging "$(basename "$0")"

readonly REL_COMPLETION_DIR=".local/share/zsh-completions"
readonly COMPLETION_DIR="${HOME}/${REL_COMPLETION_DIR}"

# Color codes for TUI rendering
readonly CYAN='\033[36m'
readonly GREEN='\033[32m'
readonly RED='\033[31m'
readonly RESET='\033[0m'

# Job tracking
declare -A JOB_PIDS=()
declare -A JOB_NAMES=()
declare -A JOB_STATUS=()
declare -A JOB_START_TIMES=()
declare -a JOB_ORDER=()
readonly JOB_TMPDIR="${TMPDIR}/install-completions-$$"
readonly JOB_TIMEOUT_SECONDS=10

#/ Usage:
#/   install-my-completions
#/
#/ Description:
#/   Installs zsh completions for common CLI tools to ~/.local/share/zsh-completions.
#/   The directory is already configured in fpath, so completions will be automatically
#/   discovered by zsh's completion system after running this script.
#/
#/ Options:
#/   --help:      Display this help message
usage() { grep '^#/' "$0" | cut -c4-; }

setup_job_tracking() {
  mkdir -p "$JOB_TMPDIR"
  trap 'rm -rf "$JOB_TMPDIR"' EXIT
}

start_job() {
  local job_id="$1"
  local job_name="$2"
  shift 2
  local job_func="$1"
  shift
  local job_args=("$@")

  local result_file="${JOB_TMPDIR}/${job_id}"

  (
    if "$job_func" "${job_args[@]}" > "${result_file}.log" 2>&1; then
      echo "success" > "$result_file"
    else
      echo "failed" > "$result_file"
    fi
  ) &

  local pid=$!
  JOB_PIDS["$job_id"]=$pid
  JOB_NAMES["$job_id"]="$job_name"
  JOB_STATUS["$job_id"]="running"
  JOB_START_TIMES["$job_id"]=$(date +%s)
  JOB_ORDER+=("$job_id")
}

check_job_status() {
  local job_id="$1"
  local pid="${JOB_PIDS[$job_id]}"
  local result_file="${JOB_TMPDIR}/${job_id}"

  if [ -f "$result_file" ]; then
    JOB_STATUS["$job_id"]=$(cat "$result_file")
    return 0
  fi

  if ! kill -0 "$pid" 2>/dev/null; then
    if [ -f "$result_file" ]; then
      JOB_STATUS["$job_id"]=$(cat "$result_file")
    else
      JOB_STATUS["$job_id"]="failed"
    fi
    return 0
  fi

  # Check for timeout
  local start_time="${JOB_START_TIMES[$job_id]}"
  local current_time
  current_time=$(date +%s)
  local elapsed=$((current_time - start_time))

  if [ "$elapsed" -ge "$JOB_TIMEOUT_SECONDS" ]; then
    kill "$pid" 2>/dev/null || true
    # Also kill any child processes
    pkill -P "$pid" 2>/dev/null || true
    JOB_STATUS["$job_id"]="timeout"
    echo "Killed after ${elapsed}s timeout" > "${result_file}.log"
    return 0
  fi

  return 1
}

wait_for_jobs() {
  local total=${#JOB_ORDER[@]}
  local completed=0

  info "╍ Sourcing ${total} completions in parallel..."

  while [ "$completed" -lt "$total" ]; do
    for job_id in "${JOB_ORDER[@]}"; do
      if [ "${JOB_STATUS[$job_id]}" = "running" ]; then
        if check_job_status "$job_id"; then
          ((++completed))
        fi
      fi
    done

    if [ "$completed" -lt "$total" ]; then
      sleep 0.1
    fi
  done
}

ensure_completion_dir() {
  if [ ! -d "$COMPLETION_DIR" ]; then
    info "╍ Creating completion directory: $COMPLETION_DIR"
    if ! mkdir -p "$COMPLETION_DIR"; then
      fatal "Failed to create completion directory at ${COMPLETION_DIR}. Check permissions and disk space."
    fi
  fi

  if [ ! -d "$COMPLETION_DIR" ]; then
    fatal "Completion directory does not exist at ${COMPLETION_DIR} after creation attempt. Check filesystem errors."
  fi
}

install_completion() {
  local tool_name="$1"
  shift
  local completion_command=("$@")

  if ! command -v "$tool_name" >/dev/null 2>&1; then
    echo "Tool '${tool_name}' not found in PATH" >&2
    return 1
  fi

  local temp_file
  temp_file=$(mktemp)

  if ! "${completion_command[@]}" > "$temp_file" 2>&1; then
    echo "Failed to generate completion for ${tool_name}" >&2
    rm -f "$temp_file"
    return 1
  fi

  if [ ! -s "$temp_file" ]; then
    echo "Generated empty completion output for ${tool_name}" >&2
    rm -f "$temp_file"
    return 1
  fi

  local completion_file="${COMPLETION_DIR}/_${tool_name}"
  if ! mv "$temp_file" "$completion_file" 2>&1; then
    echo "Failed to install completion for ${tool_name}" >&2
    rm -f "$temp_file"
    return 1
  fi

  return 0
}

install_mise_completion() {
  local tool_name="$1"
  local mise_tool_name="$2"
  shift
  shift
  local completion_args=("$@")

  if ! command -v mise >/dev/null 2>&1; then
    echo "mise not found in PATH" >&2
    return 1
  fi

  if ! mise which "$mise_tool_name" >/dev/null 2>&1; then
    echo "Tool '${mise_tool_name}' not installed in mise" >&2
    return 1
  fi

  local temp_file
  temp_file=$(mktemp)

  if ! mise exec -- "$mise_tool_name" "${completion_args[@]}" > "$temp_file" 2>&1; then
    echo "Failed to generate completion for ${tool_name}" >&2
    rm -f "$temp_file"
    return 1
  fi

  if [ ! -s "$temp_file" ]; then
    echo "Generated empty completion output for ${tool_name}" >&2
    rm -f "$temp_file"
    return 1
  fi

  local completion_file="${COMPLETION_DIR}/_${tool_name}"
  if ! mv "$temp_file" "$completion_file" 2>&1; then
    echo "Failed to install completion for ${tool_name}" >&2
    rm -f "$temp_file"
    return 1
  fi

  return 0
}

main() {
  info "▶ Installing zsh completions to ${COMPLETION_DIR}"

  # Setup PATH to include mise shims and homebrew
  export PATH="${HOME}/.local/bin:${PATH}"
  export PATH="${HOME}/.local/share/mise/shims:${PATH}"
{{ if eq .chezmoi.os "darwin" }}
  export PATH="{{ .brewprefix }}/bin:${PATH}"
{{ end }}

  ensure_completion_dir
  setup_job_tracking

  local job_num=0

  start_job "job-$((job_num++))" "mise" install_completion "mise" mise completion zsh
  start_job "job-$((job_num++))" "bws" install_mise_completion "bws" bws completions zsh
  start_job "job-$((job_num++))" "bw" install_mise_completion "bw" bw completion --shell zsh
  start_job "job-$((job_num++))" "chezmoi" install_mise_completion "chezmoi" chezmoi completion zsh
  start_job "job-$((job_num++))" "delta" install_mise_completion "delta" delta --generate-completion zsh
  start_job "job-$((job_num++))" "deno" install_mise_completion "deno" deno completions zsh
  start_job "job-$((job_num++))" "fzf" install_mise_completion "fzf" fzf --zsh
  start_job "job-$((job_num++))" "npm" install_mise_completion "npm" npm completion
  start_job "job-$((job_num++))" "starship" install_mise_completion "starship" starship completions zsh
  start_job "job-$((job_num++))" "rustup" install_mise_completion "rustup" rustup completions zsh
  start_job "job-$((job_num++))" "cargo" install_mise_completion "cargo" rustup completions zsh cargo
  start_job "job-$((job_num++))" "pnpm" install_completion "pnpm" pnpm completion zsh
  start_job "job-$((job_num++))" "opencode" install_completion "opencode" opencode completion

  wait_for_jobs

  local success_count=0
  local failed_count=0
  local timeout_count=0
  local timed_out_jobs=()

  for job_id in "${JOB_ORDER[@]}"; do
    case "${JOB_STATUS[$job_id]}" in
      success)
        ((++success_count))
        ;;
      timeout)
        ((++timeout_count))
        timed_out_jobs+=("${JOB_NAMES[$job_id]}")
        ;;
      *)
        ((++failed_count))
        ;;
    esac
  done

  info "▶ Completion installation summary:"
  info "  ✓ Installed: ${success_count}"
  if [ "$failed_count" -gt 0 ]; then
    info "  ✗ Failed: ${failed_count}"
  fi
  if [ "$timeout_count" -gt 0 ]; then
    info "  ⏱ Timed out (>${JOB_TIMEOUT_SECONDS}s): ${timeout_count} (${timed_out_jobs[*]})"
  fi

  if [ "$success_count" -eq 0 ]; then
    warning "No completions were successfully installed. Check that mise and required tools are installed."
  fi
}

main "$@"
